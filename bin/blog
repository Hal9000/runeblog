#!/usr/bin/env ruby

# $LOAD_PATH << "./lib"

require 'runeblog'
require 'rubytext'

require 'repl'

include RuneBlog::REPL

def yesno(question)
  puts fx("\n  #{question}", :bold)
  r, c = STDSCR.rc
  num, str = STDSCR.menu(r: r+1, c: c+6, items: ["yes", "no"])
  num == 0
end

def pick_editor
  choices = %w[vim emacs vi nano]
  r, c = STDSCR.rc
  num, name = STDSCR.menu(r: r+1, c: c+6, title: "Default editor", items: choices)
  file = `which #{name}`.chomp
end

def get_started
  puts
  puts fx("\n  Blog repo successfully created.", :bold)
  
  if yesno("Do you want to qo a quick setup?")
    puts "\n  First choose your editor."
    @blog.editor = pick_editor
    File.write("#{@blog.root}/data/EDITOR", @blog.editor)

    if yesno("Edit settings now?")
      fname = "#{@blog.root}/data/universal.lt3"
      edit_file(fname)
    end
    # Now create a custom global.lt3
    sleep 1
    noview = true
    puts fx("\n  Quick setup complete!", :bold)
    if yesno("Create your first view now?")
      cmd_new_view(nil)
      noview = false
      sleep 1
      puts "\n  View #{@blog.view} created!\n "
    end
  end

  sleep 0.5

  puts
  print fx("  For help", :bold)
  puts " type h or help."
  print fx("  Create a view", :bold)
  puts  " with: new view"
  print fx("  Create a post", :bold)
  puts " (within current view): new post"
end

def mainloop
  info = @blog.view || "no view"
  print fx("[#{info}] ", Red, :bold)
  cmd = STDSCR.gets(history: @cmdhist, tab: @tabcom)
  cmd_quit(nil) if cmd.nil?   # ^D
  cmd.chomp!
  return if cmd.empty?   # CR does nothing
  meth, params = RuneBlog::REPL.choose_method(cmd)
  ret, str = send(meth, params)
rescue => err
  puts err
end

def cmdline_preview
  _need_view
  local = @blog.view.local_index
  result = system("open #{local}")
end

def cmdline_publish
  abort "Nor implemented yet"
  _need_view
end

def cmdline_browse
  abort "Nor implemented yet"
  _need_view
end

def _need_view
  @view = ARGV[1]
  abort "Need 'view' parameter" if @view.nil?
  abort "No such view '#{view}'" unless @blog.view?(@view)
end

def cmdline_rebuild
  _need_view
  print "Generating view... "
  @blog.generate_view(@view)
  print "Generating index... "
  num = @blog.generate_index(@view)
  puts "#{num} posts\n "
end

def handle_cmdline
  cmd = ARGV[0]
  @blog = RuneBlog.new
  abort "No blog found" if @blog.nil?

  case cmd
    when "rebuild"; cmdline_rebuild
    when "publish"; cmdline_publish
    when "preview"; cmdline_preview
    when "browse";  cmdline_browse
  else
    puts "Command '#{cmd}' is unknown"
  end
  exit
end

### Main

major, minor = RUBY_VERSION.split(".").values_at(0,1)
ver = major.to_i*10 + minor.to_i
abort "Need Ruby 2.4 or greater" unless ver >= 24

include RuneBlog::Helpers  # for try_read_config

handle_cmdline unless ARGV.empty?

errfile = File.new("stderr.out", "w")
STDERR.reopen(errfile)

# read a .rubytext file here?? Call it something else?
home = ENV['HOME']
@fg, @bg = Blue, White   ##  FIXME!! try_read_config("#{home}/.rubytext", fg: Blue, bg: White)
@fg = @fg.downcase.to_sym
@bg = @bg.downcase.to_sym

RubyText.start(:_echo, :keypad, scroll: true, log: "binblog.txt", fg: @fg, bg: @bg)

if ! RuneBlog.exist?
  if yesno("No blog repo found. Create new one?")
    RuneBlog.create_new_blog_repo
    @blog = RuneBlog.new
    @blog.root = ".blogs"  # So far, always using default... hmm
    get_started
  else
    exit
  end
end

puts fx("\n  RuneBlog", :bold), fx(" v #{RuneBlog::VERSION}\n", Red)

@cmdhist = []
@tabcom = RuneBlog::REPL::Patterns.keys.uniq - RuneBlog::REPL::Abbr.keys
@tabcom.map! {|x| x.sub(/ [\$\>].*/, "") + " " }
@tabcom.sort!
  
loop { mainloop }

system("tput clear")
sleep 0.2
puts

